@using FluentValidation.Results
@typeparam TItem

<div class="config-item flex flex-space-between flex-row-center-v">
    <div>
        @Title
    </div>
    <div class="flex option">
        <div class="relative w100">
            <select class="@(IsValid ? "" : "error") w100" value="@SelectedIndex" @onchange="args => UpdateValue((string)args.Value!)">
                <option value="@int.Parse("-1")">--select--</option>
                @for (var i = 0; i < ItemsSource.Count(); i++)
                {
                    <option value="@i">@ItemsSource[i].ToString()</option>
                }
            </select>

            @if (!IsValid)
            {
                <div class="error-message">
                    @Failure?.ErrorMessage
                </div>
            }
        </div>

    </div>
</div>

@code {

    [Parameter]
    public string Title { get; set; }

    [Parameter]
    public TItem? SelectedItem { get; set; }

    private int SelectedIndex { get; set; }

    [Parameter]
    public List<TItem> ItemsSource { get; set; } = new();

    [Parameter]
    public ValidationFailure? Failure
    {
        get => _failure;
        set
        {
            _failure = value;
            StateHasChanged();
        }
    }

    private bool IsValid => Failure == null;

    [Parameter]
    public EventCallback<TItem> SelectedItemChanged { get; set; }

    private async Task UpdateValue(string newVal)
    {
        SelectedIndex = int.Parse(newVal);
        SelectedItem = SelectedIndex != -1 ? ItemsSource[SelectedIndex] : default;
        await SelectedItemChanged.InvokeAsync(SelectedItem);
    }

    private ValidationFailure? _failure;
}